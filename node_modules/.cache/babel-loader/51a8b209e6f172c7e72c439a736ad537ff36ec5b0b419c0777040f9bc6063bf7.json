{"ast":null,"code":"import * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { STLLoader } from 'three/examples/jsm/loaders/STLLoader';\nexport default {\n  name: '3DViewerComponent',\n  props: {\n    updateLights: Function,\n    updateEnvironment: Function,\n    updatenewFloor: Function,\n    enableHDR: Boolean,\n    showFloor: Boolean,\n    floorColor: {\n      type: String,\n      default: '#8c52ff',\n      // Initial properties of the skybox material\n      skyboxProperties: {\n        color: '#333333',\n        // Default color\n        metalness: 0.5,\n        roughness: 0.3,\n        clearcoat: 0.9,\n        clearcoatRoughness: 0.2,\n        reflectivity: 0.5\n      }\n    }\n  },\n  data() {\n    return {\n      currentHDR: '/assets/hdrs/DayInTheClouds4k.hdr',\n      currentFloor: '/assets/floors/pinkfloor2.glb',\n      currentSkybox: '/assets/skyboxes/lightbluesky.glb',\n      currentSkyboxColor: '#FFFFFF',\n      // Default color for skybox\n      isColorSkybox: false,\n      // Flag to determine skybox type\n      scene: null,\n      isReady: false,\n      fileReader: new FileReader(),\n      hdrIntensity: 2,\n      volume: 0 // This will store the volume calculated in the 3D viewer\n    };\n  },\n\n  // Add event listeners in the mounted() lifecycle hook\n  mounted() {\n    this.$options.scene = new THREE.Scene();\n    this.isReady = true;\n    // Now you can call the passed-in methods like this:\n    this.$options.scene = new THREE.Scene();\n    // Initialize other scene elements\n    this.initializeScene();\n    console.log(\"3DViewerComponent mounted\");\n    this.$emit('viewer-mounted'); // Emit a specific event\n    window.addEventListener('resize', this.handleWindowResize);\n    // Add event listeners\n    this.$emit('mounted');\n    this.$emit('update-lights', this.setupLights);\n    this.$emit('update-environment', this.loadEnvironment);\n    this.$emit('update-floor', this.loadFloor);\n    this.$emit('changeSkyboxProperty', this.updateSkyboxMaterial);\n    this.animate = this.animate.bind(this); // Bind the method\n    this.animate(); // Start the animation loop\n  },\n\n  // Remove event listeners in the beforeUnmount() lifecycle hook\n  beforeUnmount() {\n    window.removeEventListener('resize', this.handleWindowResize);\n    this.$emit.$off('update-lights', this.setupLights);\n    this.$emit.$off('update-environment', this.loadEnvironment);\n    this.$emit.$off('update-floor', this.loadFloor);\n  },\n  methods: {\n    handleWindowResize() {\n      const width = this.$refs.rendererContainer.clientWidth;\n      const height = this.$refs.rendererContainer.clientHeight;\n      this.$options.camera.aspect = width / height;\n      this.$options.camera.updateProjectionMatrix();\n      this.$options.renderer.setSize(width, height);\n    },\n    initializeScene() {\n      this.$options.scene = new THREE.Scene();\n      // Add other scene initializations here\n      console.log(\"Scene initialized\");\n      this.setupRenderer();\n      this.setupCameraAndControls();\n      this.setupLights();\n      this.loadEnvironment();\n      this.loadFloor();\n      this.animate();\n      this.loadGLTFModel();\n      this.loadReferenceCube('/assets/1cm3cube.stl');\n      this.loadSkybox(this.currentSkybox); // Load the default skybox\n\n      this.$emit('scene-initialized', this.$options.scene); // Emit an event to signal that the scene is initialized\n    },\n\n    setupRenderer() {\n      const width = this.$refs.rendererContainer.clientWidth;\n      const height = this.$refs.rendererContainer.clientHeight;\n      this.$options.scene = new THREE.Scene();\n      this.$options.scene.background = new THREE.Color(0x111111);\n      this.$options.renderer = new THREE.WebGLRenderer({\n        antialias: true\n      });\n      this.$options.renderer.setSize(width, height);\n      this.$options.renderer.setClearColor(0x111111);\n      this.$options.renderer.shadowMap.enabled = true;\n      this.$options.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.$refs.rendererContainer.appendChild(this.$options.renderer.domElement);\n    },\n    setupCameraAndControls(center) {\n      const width = this.$refs.rendererContainer.clientWidth;\n      const height = this.$refs.rendererContainer.clientHeight;\n      this.$options.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);\n      if (center) {\n        // Set the camera to look at the model\n        this.$options.camera.position.set(center.x, center.y, center.z + 70); // Increase Y and Z for more zoom-out\n        this.$options.camera.lookAt(center);\n      } else {\n        // Default position if center is not provided\n        this.$options.camera.position.set(70, 70, 70);\n      }\n      this.$options.controls = new OrbitControls(this.$options.camera, this.$options.renderer.domElement);\n      this.$options.controls.minDistance = 30; // Allow the camera to get closer\n      this.$options.controls.maxDistance = 150; // Allow the camera to move further away\n\n      if (center) {\n        this.$options.controls.target.set(center.x, center.y, center.z);\n      } else {\n        this.$options.controls.target.set(0, 0, 0);\n      }\n      this.$options.controls.update();\n    },\n    setupLights() {\n      // Ambient light to provide overall illumination\n      const ambientLight = new THREE.AmbientLight(0xffffff, 4); // Adjust intensity here\n      this.$options.scene.add(ambientLight);\n\n      // Key light (main light source)\n      const keyLight = new THREE.DirectionalLight(0xffffff, 1.0); // Adjust intensity here\n      keyLight.position.set(-50, 50, 50); // Adjust position\n      this.$options.scene.add(keyLight);\n\n      // Fill light (soft, less intense light to fill in shadows)\n      const fillLight = new THREE.DirectionalLight(0xffffff, 0.5); // Adjust intensity here\n      fillLight.position.set(50, 50, -50); // Adjust position\n      this.$options.scene.add(fillLight);\n\n      // Background light (illuminates the background or backdrop)\n      const backgroundLight = new THREE.DirectionalLight(0xffffff, 5); // Adjust intensity here\n      backgroundLight.position.set(0, 0, -100); // Adjust position\n      this.$options.scene.add(backgroundLight);\n\n      // Rim light (creates a subtle highlight on the subject's edges)\n      const rimLight = new THREE.SpotLight(0xffffff, 1.0, 0, Math.PI / 6, 1); // Adjust intensity here\n      rimLight.position.set(0, 0, 50); // Adjust position\n      this.$options.scene.add(rimLight);\n\n      // Optionally, you can configure shadow maps for specific lights\n      keyLight.castShadow = true;\n      fillLight.castShadow = true;\n      rimLight.castShadow = true;\n\n      // Set up shadow parameters (you may need to adjust these)\n      const shadowMapSize = 1024;\n      keyLight.shadow.mapSize.width = shadowMapSize;\n      keyLight.shadow.mapSize.height = shadowMapSize;\n      fillLight.shadow.mapSize.width = shadowMapSize;\n      fillLight.shadow.mapSize.height = shadowMapSize;\n      rimLight.shadow.mapSize.width = shadowMapSize;\n      rimLight.shadow.mapSize.height = shadowMapSize;\n    },\n    updateSkybox(newSkybox) {\n      console.log('Updating skybox with:', newSkybox);\n\n      // Hide the skybox color sphere if it exists\n      if (this.skyboxColorSphere) {\n        this.skyboxColorSphere.visible = false;\n      }\n      if (newSkybox) {\n        // If a new skybox is provided, use it\n        this.currentSkybox = newSkybox;\n        this.isColorSkybox = false; // Reset the color skybox flag\n        this.loadSkybox(); // Load the new skybox into the scene\n      } else {\n        // If no new skybox is provided, use the default\n        this.currentSkybox = this.defaultSkybox;\n        this.loadSkybox(); // Load the default skybox into the scene\n      }\n    },\n\n    loadSkybox() {\n      // Remove the previous skybox from the scene if it exists\n      if (this.skyboxMesh) {\n        this.$options.scene.remove(this.skyboxMesh);\n        this.skyboxMesh = null; // Ensure the previous mesh is cleared\n\n        // Remove the background color\n        this.$options.scene.background = null;\n      }\n      if (this.isColorSkybox && this.currentSkyboxColor) {\n        // Create a geometry for the skybox. Here, we use a BoxGeometry.\n        const skyboxGeometry = new THREE.BoxGeometry(5000, 5000, 5000);\n\n        // Create a material with the color selected\n        const skyboxMaterial = new THREE.MeshPhysicalMaterial({\n          color: this.currentSkyboxColor,\n          // Base color\n          metalness: 0.5,\n          // 0.0 for non-metallic, 1.0 for fully metallic\n          roughness: 0.3,\n          // 0.0 for smooth, 1.0 for rough\n          clearcoat: 0.9,\n          // Intensity of the clearcoat layer\n          clearcoatRoughness: 0.2,\n          // Roughness of the clearcoat layer\n          reflectivity: 0.5,\n          // Overall reflectivity\n          side: THREE.BackSide // Important for skybox\n        });\n\n        // Create a mesh with the geometry and material\n        this.skyboxMesh = new THREE.Mesh(skyboxGeometry, skyboxMaterial);\n\n        // Add the skybox mesh to the scene\n        this.$options.scene.add(this.skyboxMesh);\n      } else {\n        // Load the default or specified skybox\n        const loader = new GLTFLoader();\n        loader.load(this.currentSkybox, gltfSkybox => {\n          this.skyboxMesh = gltfSkybox.scene;\n          this.$options.scene.add(this.skyboxMesh);\n        }, undefined, error => {\n          console.error(\"Error loading skybox:\", error);\n        });\n      }\n    },\n    updateSkyboxMaterial(properties) {\n      // Ensure properties are reactive\n      this.$nextTick(() => {\n        console.log(\"Received properties for update:\", properties);\n\n        // Create a default color if none is provided\n        const defaultColor = '#ffffff'; // white color as default\n        const colorValue = properties.color ?? defaultColor;\n\n        // Ensure the color value is a string and starts with '#'\n        const color = new THREE.Color(colorValue.startsWith('#') ? colorValue : `#${colorValue}`);\n        console.log(\"THREE.Color object created:\", color);\n\n        // If the skybox material already exists, update its properties\n        if (this.skyboxMaterial) {\n          this.skyboxMaterial.color.set(color); // Update color\n          this.skyboxMaterial.metalness = properties.metalness ?? this.skyboxMaterial.metalness;\n          this.skyboxMaterial.roughness = properties.roughness ?? this.skyboxMaterial.roughness;\n          this.skyboxMaterial.clearcoat = properties.clearcoat ?? this.skyboxMaterial.clearcoat;\n          this.skyboxMaterial.clearcoatRoughness = properties.clearcoatRoughness ?? this.skyboxMaterial.clearcoatRoughness;\n          this.skyboxMaterial.reflectivity = properties.reflectivity ?? this.skyboxMaterial.reflectivity;\n          this.skyboxMaterial.needsUpdate = true; // Tell Three.js to update the material\n          console.log(\"updated material\");\n        } else {\n          // If the material does not exist, create it with new properties\n          this.skyboxMaterial = new THREE.MeshPhysicalMaterial({\n            color: color,\n            metalness: properties.metalness ?? 0.5,\n            roughness: properties.roughness ?? 0.3,\n            clearcoat: properties.clearcoat ?? 0.9,\n            clearcoatRoughness: properties.clearcoatRoughness ?? 0.2,\n            reflectivity: properties.reflectivity ?? 0.5,\n            side: THREE.BackSide\n          });\n          console.log(\"updated material1\");\n          // Assuming you have a mesh that uses this material, set it here\n          this.skyboxMaterial.needsUpdate = true; // Tell Three.js to recompile the material's shaders\n          this.skyboxMesh.material = this.skyboxMaterial; // Apply the updated material to the mesh\n        }\n\n        // Update the scene background if a color is provided\n        if (properties.color) {\n          this.$options.scene.background.set(color); // Set the background to the new color\n        }\n\n        // Render the scene again to reflect the changes\n        this.$options.renderer.render(this.$options.scene, this.$options.camera);\n      });\n    },\n    updateHDR(newHDR) {\n      console.log('Updating HDR with:', newHDR);\n      this.currentHDR = `/assets/hdrs/${newHDR}`;\n      this.loadEnvironment(); // Load the new HDR environment\n    },\n\n    updateFloor(newFloor) {\n      console.log('Updating floor with:', newFloor);\n      this.currentFloor = `/assets/floors/${newFloor}`;\n      this.loadFloor(); // Load the new floor into the scene\n    },\n\n    updateFloorColor(newColorHex) {\n      if (this.floorMesh) {\n        const newColor = new THREE.Color(newColorHex);\n        this.floorMesh.traverse(node => {\n          if (node.isMesh && node.material) {\n            node.material.color.copy(newColor);\n          }\n        });\n      }\n    },\n    loadEnvironment() {\n      const pmremGenerator = new THREE.PMREMGenerator(this.$options.renderer);\n      pmremGenerator.compileEquirectangularShader();\n      new RGBELoader().setDataType(THREE.FloatType).load(this.currentHDR, texture => {\n        const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n\n        // Adjust the intensity here\n        envMap.encoding = THREE.sRGBEncoding; // Ensure correct encoding\n        this.$options.scene.environment = envMap;\n        this.$options.scene.environment.intensity = this.hdrIntensity; // Set intensity\n\n        texture.dispose();\n        pmremGenerator.dispose();\n\n        // Check if this.floorMesh is defined before accessing its properties\n        if (this.floorMesh) {\n          // Set the position and scale for the environment\n          this.floorMesh.position.set(0, -8.5, 0); // Horizontal position at y = -0.09\n          this.floorMesh.scale.set(20, 20, 20); // Scale to reach the origin minus 20 units\n        }\n      });\n    },\n\n    updateHDRIntensity(newIntensity) {\n      this.hdrIntensity = newIntensity;\n      if (this.$options.scene && this.$options.scene.environment) {\n        this.$options.scene.environment.intensity = newIntensity;\n      }\n    },\n    loadFloor() {\n      const loader = new GLTFLoader();\n\n      // Remove the previous floor if it exists\n      if (this.floorMesh) {\n        this.$options.scene.remove(this.floorMesh);\n      }\n      loader.load(this.currentFloor, gltfFloor => {\n        if (gltfFloor.scene) {\n          this.floorMesh = gltfFloor.scene;\n\n          // Set the position and scale for the floor\n          this.floorMesh.position.set(0, -8.5, 0); // Horizontal position at y = -0.09\n          this.floorMesh.scale.set(27, 0.01, 27); // Scale to reach the origin minus 20 units\n\n          // Traverse through the nodes and apply the new color to the floor\n          this.floorMesh.traverse(node => {\n            if (node.isMesh && node.material) {\n              node.material.color.copy(new THREE.Color(this.floorColor));\n            }\n          });\n          this.$options.scene.add(this.floorMesh);\n        } else {\n          console.error(\"Failed to load the floor model or scene is undefined.\");\n        }\n      }, undefined, error => {\n        console.error(\"Error loading floor model:\", error);\n      });\n    },\n    loadReferenceCube(cubePath) {\n      const loader = new STLLoader();\n      loader.load(cubePath, geometry => {\n        const material = new THREE.MeshStandardMaterial({\n          visible: false\n        }); // Invisible as it's just for reference\n        const cubeMesh = new THREE.Mesh(geometry, material);\n        this.$options.scene.add(cubeMesh);\n        this.referenceCube = cubeMesh; // Store for later use\n      });\n    },\n\n    calculateScalingFactor(mesh) {\n      // Use Squirtle's volume as a reference\n      const squirtleVolume = 203320; // Volume of Squirtle in mm3\n      const modelVolume = this.calculateVolume(mesh.geometry); // Calculate the volume of the STL model\n\n      // Calculate scaling factor based on the volume ratio\n      return Math.cbrt(modelVolume / squirtleVolume);\n    },\n    calculateVolume(geometry) {\n      // Check if geometry is undefined or not a BufferGeometry\n      if (!geometry ?? !(geometry instanceof THREE.BufferGeometry)) {\n        console.error('Invalid or undefined geometry passed to calculateVolume.');\n        return 0;\n      }\n\n      // Get position attribute\n      const positionAttribute = geometry.getAttribute('position');\n\n      // Check if position attribute exists\n      if (!positionAttribute) {\n        console.error('Geometry does not have position attribute.');\n        return 0;\n      }\n      let volume = 0;\n\n      // Iterate over each face (assuming geometry is made of triangles)\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        // Get vertices of the triangle\n        const v1 = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);\n        const v2 = new THREE.Vector3().fromBufferAttribute(positionAttribute, i + 1);\n        const v3 = new THREE.Vector3().fromBufferAttribute(positionAttribute, i + 2);\n\n        // Calculate volume of the tetrahedron\n        const tetraVolume = v1.dot(v2.cross(v3)) / 6;\n        volume += tetraVolume;\n      }\n\n      // Convert to absolute value as the volume can be negative depending on the winding order of triangles\n      volume = Math.abs(volume);\n\n      // Convert volume from cubic millimeters to milliliters (1 mL = 1000 mm^3)\n      const volumeInMilliliters = volume / 1000;\n      this.$emit('volume-calculated', volumeInMilliliters);\n\n      // Return volume in milliliters\n      return volumeInMilliliters;\n    },\n    calculateDimensions(geometry) {\n      geometry.computeBoundingBox();\n      const boundingBox = geometry.boundingBox;\n      const width = Math.abs(boundingBox.max.x - boundingBox.min.x);\n      const height = Math.abs(boundingBox.max.y - boundingBox.min.y);\n      const depth = Math.abs(boundingBox.max.z - boundingBox.min.z);\n      // Emit an event with the calculated height\n      // Emit an event with the calculated height and original dimensions\n      console.log(\"Emitting height and original dimensions:\", {\n        height,\n        originalDimensions: {\n          width,\n          height,\n          depth\n        }\n      });\n      this.$emit('height-calculated', {\n        height,\n        originalDimensions: {\n          width,\n          height,\n          depth\n        }\n      });\n      return {\n        width,\n        height,\n        depth\n      };\n    },\n    positionModelInScene(model) {\n      // Set the position of the model in the scene\n      // Adjust these values based on where you want to place the model\n      model.position.set(0, 0, 0);\n    },\n    loadGLTFModel() {\n      const loader = new GLTFLoader();\n      loader.load('/assets/resinprinter/scene.gltf', gltf => {\n        // Get the bounding box of the loaded GLTF model\n        const box = new THREE.Box3().setFromObject(gltf.scene);\n        const currentDimensions = box.getSize(new THREE.Vector3());\n\n        // Desired dimensions in mm (assuming 1 unit = 1mm)\n        const desiredDimensions = new THREE.Vector3(22.1, 40.3, 22.1);\n\n        // Calculate scaling factors\n        const scaleX = desiredDimensions.x / currentDimensions.x;\n        const scaleY = desiredDimensions.y / currentDimensions.y;\n        const scaleZ = desiredDimensions.z / currentDimensions.z;\n\n        // Apply scaling\n        gltf.scene.scale.set(scaleX, scaleY, scaleZ);\n\n        // Apply shadow and material properties\n        gltf.scene.traverse(node => {\n          if (node.isMesh && node.material) {\n            node.castShadow = true;\n            node.receiveShadow = true;\n            node.material.specular = new THREE.Color(0xaaaaaa);\n            node.material.shininess = 30;\n          }\n        });\n\n        // Add the resin printer to the scene\n        this.$options.scene.add(gltf.scene);\n\n        // Get the center of the scaled model\n        // const center = box.getCenter(new THREE.Vector3());\n        // Get the center of the scaled model\n        const center = new THREE.Box3().setFromObject(gltf.scene).getCenter(new THREE.Vector3());\n\n        // Call setupCameraAndControls with the center\n        this.setupCameraAndControls(center);\n\n        // // Add a PointLight at the center of the model\n        const innerLight = new THREE.PointLight(0xffffff, 0.1, 10);\n        innerLight.position.set(center.x, center.y, center.z);\n        this.$options.scene.add(innerLight);\n\n        // // Load the environment\n        loader.load('/assets/skyboxes/skyboxanimesky.glb', gltfSky => {\n          this.$options.scene.add(gltfSky.scene);\n\n          // Scale the skybox to be larger\n          gltfSky.scene.scale.set(50000, 50000, 5000); // Adjust the scale as needed\n\n          gltfSky.scene.traverse(node => {\n            if (node.isMesh) {\n              node.castShadow = true;\n              node.receiveShadow = true;\n            }\n          });\n        });\n      });\n    },\n    loadSTLModel(file) {\n      // Check if the file is of the correct type\n      if (!(file instanceof Blob)) {\n        console.error('Invalid file type:', file);\n        return;\n      }\n\n      // Make sure the fileReader is initialized\n      if (!this.fileReader) {\n        this.fileReader = new FileReader();\n      }\n      console.log('Loading STL model:', file.name);\n      const loader = new STLLoader();\n      const self = this;\n\n      // If there is a previously loaded STL model, remove it\n      if (self.loadedSTL) {\n        self.$options.scene.remove(self.loadedSTL);\n      }\n      self.fileReader.onload = e => {\n        console.log('File read completed, parsing geometry');\n        const geometry = loader.parse(e.target.result);\n        if (!geometry) {\n          console.error('Error parsing STL geometry');\n          return;\n        }\n        console.log('Geometry parsed successfully');\n        const material = new THREE.MeshStandardMaterial();\n        const mesh = new THREE.Mesh(geometry, material);\n        if (!geometry ?? geometry.type !== 'BufferGeometry') {\n          console.error('Invalid or undefined geometry');\n          return;\n        }\n\n        // Calculate the scaling factor based on the reference cube\n        const scalingFactor = this.calculateScalingFactor(geometry, this.referenceCube);\n        mesh.scale.set(scalingFactor, scalingFactor, scalingFactor); // Apply scaling\n\n        // Calculate and log the dimensions and volume of the STL model\n        const dimensions = this.calculateDimensions(geometry);\n        const printVolume = this.calculateVolume(geometry);\n        console.log(`STL Model Dimensions: ${dimensions.width / 10} x ${dimensions.height / 10} x ${dimensions.depth / 10} cm`);\n        console.log(`STL Model Volume: ${printVolume} mL`);\n        this.$emit('volume-calculated', printVolume);\n\n        // Scale down by a factor of 10\n        mesh.scale.set(0.1, 0.1, 0.1);\n\n        // Rotate the model to be upside down\n        mesh.rotation.z = Math.PI; // Rotate by 180 degrees around the Z-axis\n        mesh.rotation.x = Math.PI / 2; // Rotate by 90 degrees around the X-axis\n\n        // Load the GLTF model to get its center and size\n        const gltfLoader = new GLTFLoader();\n        gltfLoader.load('/assets/resinprinter/scene.gltf', gltf => {\n          const gltfBox = new THREE.Box3().setFromObject(gltf.scene);\n          const gltfCenter = gltfBox.getCenter(new THREE.Vector3());\n\n          // Position the STL model in the middle of the GLTF model with its top at the floor\n          mesh.position.set(gltfCenter.x - 1, gltfCenter.y + 18.5, gltfCenter.z + 11);\n\n          // Set the currently loaded STL model\n          self.loadedSTL = mesh;\n          console.log('Adding mesh to scene');\n          self.$options.scene.add(mesh);\n        });\n      };\n      self.fileReader.onerror = error => {\n        console.error('Error reading STL file:', error);\n      };\n      console.log('Reading STL file contents');\n      self.fileReader.readAsArrayBuffer(file);\n    },\n    animate() {\n      requestAnimationFrame(this.animate); // This ensures the animate method is called on the next frame\n      this.$options.renderer.render(this.$options.scene, this.$options.camera); // Render the scene with the camera\n    }\n  },\n\n  watch: {\n    floorColor(newColor) {\n      this.updateFloorColor(newColor);\n    },\n    enableHDR(newVal) {\n      if (newVal) {\n        this.loadEnvironment(); // Turn on HDR\n      } else {\n        this.$options.scene.environment = null; // Turn off HDR\n      }\n    },\n\n    showFloor(newVal) {\n      if (this.floorMesh) {\n        this.floorMesh.visible = newVal; // Toggle floor visibility\n      }\n    }\n  }\n};","map":{"version":3,"names":["THREE","GLTFLoader","OrbitControls","RGBELoader","STLLoader","name","props","updateLights","Function","updateEnvironment","updatenewFloor","enableHDR","Boolean","showFloor","floorColor","type","String","default","skyboxProperties","color","metalness","roughness","clearcoat","clearcoatRoughness","reflectivity","data","currentHDR","currentFloor","currentSkybox","currentSkyboxColor","isColorSkybox","scene","isReady","fileReader","FileReader","hdrIntensity","volume","mounted","$options","Scene","initializeScene","console","log","$emit","window","addEventListener","handleWindowResize","setupLights","loadEnvironment","loadFloor","updateSkyboxMaterial","animate","bind","beforeUnmount","removeEventListener","$off","methods","width","$refs","rendererContainer","clientWidth","height","clientHeight","camera","aspect","updateProjectionMatrix","renderer","setSize","setupRenderer","setupCameraAndControls","loadGLTFModel","loadReferenceCube","loadSkybox","background","Color","WebGLRenderer","antialias","setClearColor","shadowMap","enabled","PCFSoftShadowMap","appendChild","domElement","center","PerspectiveCamera","position","set","x","y","z","lookAt","controls","minDistance","maxDistance","target","update","ambientLight","AmbientLight","add","keyLight","DirectionalLight","fillLight","backgroundLight","rimLight","SpotLight","Math","PI","castShadow","shadowMapSize","shadow","mapSize","updateSkybox","newSkybox","skyboxColorSphere","visible","defaultSkybox","skyboxMesh","remove","skyboxGeometry","BoxGeometry","skyboxMaterial","MeshPhysicalMaterial","side","BackSide","Mesh","loader","load","gltfSkybox","undefined","error","properties","$nextTick","defaultColor","colorValue","startsWith","needsUpdate","material","render","updateHDR","newHDR","updateFloor","newFloor","updateFloorColor","newColorHex","floorMesh","newColor","traverse","node","isMesh","copy","pmremGenerator","PMREMGenerator","compileEquirectangularShader","setDataType","FloatType","texture","envMap","fromEquirectangular","encoding","sRGBEncoding","environment","intensity","dispose","scale","updateHDRIntensity","newIntensity","gltfFloor","cubePath","geometry","MeshStandardMaterial","cubeMesh","referenceCube","calculateScalingFactor","mesh","squirtleVolume","modelVolume","calculateVolume","cbrt","BufferGeometry","positionAttribute","getAttribute","i","count","v1","Vector3","fromBufferAttribute","v2","v3","tetraVolume","dot","cross","abs","volumeInMilliliters","calculateDimensions","computeBoundingBox","boundingBox","max","min","depth","originalDimensions","positionModelInScene","model","gltf","box","Box3","setFromObject","currentDimensions","getSize","desiredDimensions","scaleX","scaleY","scaleZ","receiveShadow","specular","shininess","getCenter","innerLight","PointLight","gltfSky","loadSTLModel","file","Blob","self","loadedSTL","onload","e","parse","result","scalingFactor","dimensions","printVolume","rotation","gltfLoader","gltfBox","gltfCenter","onerror","readAsArrayBuffer","requestAnimationFrame","watch","newVal"],"sources":["/Users/max/Documents/3DPrintprice-1/src/components/3DViewerComponent.vue"],"sourcesContent":["Look at this code and view the video:\n\n<template>\n  <div ref=\"rendererContainer\" style=\"width: 100%; height: 100%;\"></div>\n</template>\n\n<script>\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { STLLoader } from 'three/examples/jsm/loaders/STLLoader';\n\n\nexport default {\n  name: '3DViewerComponent',\n  props: {\n    updateLights: Function,\n    updateEnvironment: Function,\n    updatenewFloor: Function,\n    enableHDR: Boolean,\n    showFloor: Boolean,\n    floorColor: {\n    type: String,\n    default: '#8c52ff',\n    // Initial properties of the skybox material\n    skyboxProperties: {\n      color: '#333333', // Default color\n      metalness: 0.5,\n      roughness: 0.3,\n      clearcoat: 0.9,\n      clearcoatRoughness: 0.2,\n      reflectivity: 0.5,\n    },\n  }\n    \n  },\n\ndata() {\n    return {\n      currentHDR: '/assets/hdrs/DayInTheClouds4k.hdr',\n      currentFloor: '/assets/floors/pinkfloor2.glb',\n      currentSkybox: '/assets/skyboxes/lightbluesky.glb',\n      currentSkyboxColor: '#FFFFFF', // Default color for skybox\n      isColorSkybox: false, // Flag to determine skybox type\n      scene: null,\n      isReady: false,\n      fileReader: new FileReader(),\n      hdrIntensity: 2, \n      volume: 0, // This will store the volume calculated in the 3D viewer\n\n    };\n  },\n  \n// Add event listeners in the mounted() lifecycle hook\nmounted() {\n  this.$options.scene = new THREE.Scene();\n  this.isReady = true;\n    // Now you can call the passed-in methods like this:\n  this.$options.scene = new THREE.Scene();\n    // Initialize other scene elements\n  this.initializeScene();\n  \n  console.log(\"3DViewerComponent mounted\");\n  this.$emit('viewer-mounted'); // Emit a specific event\n  window.addEventListener('resize', this.handleWindowResize);\n// Add event listeners\n this.$emit('mounted'); \nthis.$emit('update-lights', this.setupLights); \nthis.$emit('update-environment', this.loadEnvironment);\nthis.$emit('update-floor', this.loadFloor);\nthis.$emit('changeSkyboxProperty', this.updateSkyboxMaterial);\n\nthis.animate = this.animate.bind(this); // Bind the method\n  this.animate(); // Start the animation loop\n\n\n\n},\n\n// Remove event listeners in the beforeUnmount() lifecycle hook\nbeforeUnmount() {\n  window.removeEventListener('resize', this.handleWindowResize);\n  this.$emit.$off('update-lights', this.setupLights);\n  this.$emit.$off('update-environment', this.loadEnvironment);\n  this.$emit.$off('update-floor', this.loadFloor); \n},\n\n  methods: {\n    \n    handleWindowResize() {\n      const width = this.$refs.rendererContainer.clientWidth;\n      const height = this.$refs.rendererContainer.clientHeight;\n      this.$options.camera.aspect = width / height;\n      this.$options.camera.updateProjectionMatrix();\n      this.$options.renderer.setSize(width, height);\n    },\n    initializeScene() {\n      \n      this.$options.scene = new THREE.Scene();\n      // Add other scene initializations here\n      console.log(\"Scene initialized\"); \n\n      this.setupRenderer();\n      this.setupCameraAndControls();\n      this.setupLights();\n      this.loadEnvironment();\n      this.loadFloor(); \n      this.animate();\n      this.loadGLTFModel();\n      this.loadReferenceCube('/assets/1cm3cube.stl');\n      this.loadSkybox(this.currentSkybox); // Load the default skybox\n     \n\n      this.$emit('scene-initialized', this.$options.scene); // Emit an event to signal that the scene is initialized\n\n    },\n\n    setupRenderer() {\n      const width = this.$refs.rendererContainer.clientWidth;\n      const height = this.$refs.rendererContainer.clientHeight;\n\n      this.$options.scene = new THREE.Scene();\n      this.$options.scene.background = new THREE.Color(0x111111);\n\n      this.$options.renderer = new THREE.WebGLRenderer({ antialias: true });\n      this.$options.renderer.setSize(width, height);\n      this.$options.renderer.setClearColor(0x111111);\n      this.$options.renderer.shadowMap.enabled = true;\n      this.$options.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.$refs.rendererContainer.appendChild(this.$options.renderer.domElement);\n    },\n\n    setupCameraAndControls(center) {\n      const width = this.$refs.rendererContainer.clientWidth;\n  const height = this.$refs.rendererContainer.clientHeight;\n\n  this.$options.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);\n\n  if (center) {\n    // Set the camera to look at the model\n    this.$options.camera.position.set(center.x, center.y , center.z + 70); // Increase Y and Z for more zoom-out\n    this.$options.camera.lookAt(center);\n  } else {\n    // Default position if center is not provided\n    this.$options.camera.position.set(70, 70, 70);\n  }\n\n  this.$options.controls = new OrbitControls(this.$options.camera, this.$options.renderer.domElement);\n  this.$options.controls.minDistance = 30; // Allow the camera to get closer\n  this.$options.controls.maxDistance = 150; // Allow the camera to move further away\n\n  if (center) {\n    this.$options.controls.target.set(center.x, center.y, center.z);\n  } else {\n    this.$options.controls.target.set(0, 0, 0);\n  }\n\n  this.$options.controls.update();\n},\n\n\n\n\n    setupLights() {\n  // Ambient light to provide overall illumination\n  const ambientLight = new THREE.AmbientLight(0xffffff, 4); // Adjust intensity here\n  this.$options.scene.add(ambientLight);\n\n  // Key light (main light source)\n  const keyLight = new THREE.DirectionalLight(0xffffff, 1.0); // Adjust intensity here\n  keyLight.position.set(-50, 50, 50); // Adjust position\n  this.$options.scene.add(keyLight);\n\n  // Fill light (soft, less intense light to fill in shadows)\n  const fillLight = new THREE.DirectionalLight(0xffffff, 0.5); // Adjust intensity here\n  fillLight.position.set(50, 50, -50); // Adjust position\n  this.$options.scene.add(fillLight);\n\n  // Background light (illuminates the background or backdrop)\n  const backgroundLight = new THREE.DirectionalLight(0xffffff, 5); // Adjust intensity here\n  backgroundLight.position.set(0, 0, -100); // Adjust position\n  this.$options.scene.add(backgroundLight);\n\n  // Rim light (creates a subtle highlight on the subject's edges)\n  const rimLight = new THREE.SpotLight(0xffffff, 1.0, 0, Math.PI / 6, 1); // Adjust intensity here\n  rimLight.position.set(0, 0, 50); // Adjust position\n  this.$options.scene.add(rimLight);\n\n  // Optionally, you can configure shadow maps for specific lights\n  keyLight.castShadow = true;\n  fillLight.castShadow = true;\n  rimLight.castShadow = true;\n\n  // Set up shadow parameters (you may need to adjust these)\n  const shadowMapSize = 1024;\n  keyLight.shadow.mapSize.width = shadowMapSize;\n  keyLight.shadow.mapSize.height = shadowMapSize;\n  fillLight.shadow.mapSize.width = shadowMapSize;\n  fillLight.shadow.mapSize.height = shadowMapSize;\n  rimLight.shadow.mapSize.width = shadowMapSize;\n  rimLight.shadow.mapSize.height = shadowMapSize;\n},\n\n\nupdateSkybox(newSkybox) {\n    console.log('Updating skybox with:', newSkybox);\n\n    // Hide the skybox color sphere if it exists\n    if (this.skyboxColorSphere) {\n        this.skyboxColorSphere.visible = false;\n    }\n\n    if (newSkybox) {\n        // If a new skybox is provided, use it\n        this.currentSkybox = newSkybox;\n        this.isColorSkybox = false; // Reset the color skybox flag\n        this.loadSkybox(); // Load the new skybox into the scene\n    } else {\n        // If no new skybox is provided, use the default\n        this.currentSkybox = this.defaultSkybox;\n        this.loadSkybox(); // Load the default skybox into the scene\n    }\n},\n\n    loadSkybox() {\n      \n  // Remove the previous skybox from the scene if it exists\n  if (this.skyboxMesh) {\n    this.$options.scene.remove(this.skyboxMesh);\n    this.skyboxMesh = null; // Ensure the previous mesh is cleared\n\n    // Remove the background color\n    this.$options.scene.background = null;\n  }\n\n  if (this.isColorSkybox && this.currentSkyboxColor) {\n    // Create a geometry for the skybox. Here, we use a BoxGeometry.\n    const skyboxGeometry = new THREE.BoxGeometry(5000, 5000, 5000);\n\n    // Create a material with the color selected\n    const skyboxMaterial = new THREE.MeshPhysicalMaterial({\n  color: this.currentSkyboxColor, // Base color\n  metalness: 0.5, // 0.0 for non-metallic, 1.0 for fully metallic\n  roughness: 0.3, // 0.0 for smooth, 1.0 for rough\n  clearcoat: 0.9, // Intensity of the clearcoat layer\n  clearcoatRoughness: 0.2, // Roughness of the clearcoat layer\n  reflectivity: 0.5, // Overall reflectivity\n  side: THREE.BackSide, // Important for skybox\n});\n\n    \n    // Create a mesh with the geometry and material\n    this.skyboxMesh = new THREE.Mesh(skyboxGeometry, skyboxMaterial);\n\n    // Add the skybox mesh to the scene\n    this.$options.scene.add(this.skyboxMesh);\n  } else {\n    // Load the default or specified skybox\n    const loader = new GLTFLoader();\n    loader.load(this.currentSkybox, (gltfSkybox) => {\n      this.skyboxMesh = gltfSkybox.scene;\n      this.$options.scene.add(this.skyboxMesh);\n    }, undefined, (error) => {\n      console.error(\"Error loading skybox:\", error);\n    });\n  }\n},\n\n\nupdateSkyboxMaterial(properties) {\n  // Ensure properties are reactive\n  this.$nextTick(() => {\n    console.log(\"Received properties for update:\", properties);\n\n    // Create a default color if none is provided\n    const defaultColor = '#ffffff'; // white color as default\n    const colorValue = properties.color ?? defaultColor;\n\n    // Ensure the color value is a string and starts with '#'\n    const color = new THREE.Color(colorValue.startsWith('#') ? colorValue : `#${colorValue}`);\n    console.log(\"THREE.Color object created:\", color);\n\n    // If the skybox material already exists, update its properties\n    if (this.skyboxMaterial) {\n    \n      this.skyboxMaterial.color.set(color); // Update color\n      this.skyboxMaterial.metalness = properties.metalness ?? this.skyboxMaterial.metalness;\n      this.skyboxMaterial.roughness = properties.roughness ?? this.skyboxMaterial.roughness;\n      this.skyboxMaterial.clearcoat = properties.clearcoat ?? this.skyboxMaterial.clearcoat;\n      this.skyboxMaterial.clearcoatRoughness = properties.clearcoatRoughness ?? this.skyboxMaterial.clearcoatRoughness;\n      this.skyboxMaterial.reflectivity = properties.reflectivity ?? this.skyboxMaterial.reflectivity;\n      this.skyboxMaterial.needsUpdate = true; // Tell Three.js to update the material\n      console.log(\"updated material\");\n    } else {\n      // If the material does not exist, create it with new properties\n      this.skyboxMaterial = new THREE.MeshPhysicalMaterial({\n        color: color,\n        metalness: properties.metalness ?? 0.5,\n        roughness: properties.roughness ?? 0.3,\n        clearcoat: properties.clearcoat ?? 0.9,\n        clearcoatRoughness: properties.clearcoatRoughness ?? 0.2,\n        reflectivity: properties.reflectivity ?? 0.5,\n        side: THREE.BackSide,\n      });\n      console.log(\"updated material1\");\n      // Assuming you have a mesh that uses this material, set it here\n      this.skyboxMaterial.needsUpdate = true; // Tell Three.js to recompile the material's shaders\nthis.skyboxMesh.material = this.skyboxMaterial; // Apply the updated material to the mesh\n    }\n\n    // Update the scene background if a color is provided\n    if (properties.color) {\n      this.$options.scene.background.set(color); // Set the background to the new color\n    }\n\n    // Render the scene again to reflect the changes\n    this.$options.renderer.render(this.$options.scene, this.$options.camera);\n    \n  });\n},\n\n\n\n\n    updateHDR(newHDR) {\n  console.log('Updating HDR with:', newHDR);\n  this.currentHDR = `/assets/hdrs/${newHDR}`;\n  this.loadEnvironment(); // Load the new HDR environment\n},\n\nupdateFloor(newFloor) {\n    console.log('Updating floor with:', newFloor);\n    this.currentFloor = `/assets/floors/${newFloor}`;\n    this.loadFloor(); // Load the new floor into the scene\n  },\n\n\n  updateFloorColor(newColorHex) {\n      if (this.floorMesh) {\n      const newColor = new THREE.Color(newColorHex);\n      this.floorMesh.traverse((node) => {\n        if (node.isMesh && node.material) {\n          node.material.color.copy(newColor);\n      }\n    });\n  }\n},\n\nloadEnvironment() {\n  const pmremGenerator = new THREE.PMREMGenerator(this.$options.renderer);\n  pmremGenerator.compileEquirectangularShader();\n\n  new RGBELoader()\n    .setDataType(THREE.FloatType)\n    .load(this.currentHDR, (texture) => {\n      const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n      \n      // Adjust the intensity here\n      envMap.encoding = THREE.sRGBEncoding; // Ensure correct encoding\n      this.$options.scene.environment = envMap;\n      this.$options.scene.environment.intensity = this.hdrIntensity; // Set intensity\n\n      texture.dispose();\n      pmremGenerator.dispose();\n\n\n      // Check if this.floorMesh is defined before accessing its properties\n      if (this.floorMesh) {\n        // Set the position and scale for the environment\n        this.floorMesh.position.set(0, -8.5, 0); // Horizontal position at y = -0.09\n        this.floorMesh.scale.set(20, 20, 20); // Scale to reach the origin minus 20 units\n      }\n    });\n},\n\nupdateHDRIntensity(newIntensity) {\n  this.hdrIntensity = newIntensity;\n  if (this.$options.scene && this.$options.scene.environment) {\n    this.$options.scene.environment.intensity = newIntensity;\n  }\n},\n\nloadFloor() {\n  const loader = new GLTFLoader();\n\n  // Remove the previous floor if it exists\n  if (this.floorMesh) {\n    this.$options.scene.remove(this.floorMesh);\n  }\n\n  loader.load(this.currentFloor, (gltfFloor) => {\n  if (gltfFloor.scene) {\n    this.floorMesh = gltfFloor.scene;\n\n    // Set the position and scale for the floor\n    this.floorMesh.position.set(0, -8.5, 0); // Horizontal position at y = -0.09\n    this.floorMesh.scale.set(27, 0.01, 27); // Scale to reach the origin minus 20 units\n\n    // Traverse through the nodes and apply the new color to the floor\n    this.floorMesh.traverse((node) => {\n      if (node.isMesh && node.material) {\n        node.material.color.copy(new THREE.Color(this.floorColor));\n      }\n    });\n\n    this.$options.scene.add(this.floorMesh);\n  } else {\n    console.error(\"Failed to load the floor model or scene is undefined.\");\n  }\n}, undefined, (error) => {\n  console.error(\"Error loading floor model:\", error);\n});\n\n},\n\nloadReferenceCube(cubePath) {\n  const loader = new STLLoader();\n  loader.load(cubePath, (geometry) => {\n    const material = new THREE.MeshStandardMaterial({visible: false}); // Invisible as it's just for reference\n    const cubeMesh = new THREE.Mesh(geometry, material);\n    this.$options.scene.add(cubeMesh);\n    this.referenceCube = cubeMesh; // Store for later use\n  });\n},\n\n\ncalculateScalingFactor(mesh) {\n  // Use Squirtle's volume as a reference\n  const squirtleVolume = 203320; // Volume of Squirtle in mm3\n  const modelVolume = this.calculateVolume(mesh.geometry); // Calculate the volume of the STL model\n\n  // Calculate scaling factor based on the volume ratio\n  return Math.cbrt(modelVolume / squirtleVolume);\n},\n\ncalculateVolume(geometry) {\n  // Check if geometry is undefined or not a BufferGeometry\n  if (!geometry ?? !(geometry instanceof THREE.BufferGeometry)) {\n    console.error('Invalid or undefined geometry passed to calculateVolume.');\n    return 0;\n  }\n\n  // Get position attribute\n  const positionAttribute = geometry.getAttribute('position');\n\n  // Check if position attribute exists\n  if (!positionAttribute) {\n    console.error('Geometry does not have position attribute.');\n    return 0;\n  }\n\n  let volume = 0;\n\n  // Iterate over each face (assuming geometry is made of triangles)\n  for (let i = 0; i < positionAttribute.count; i += 3) {\n    // Get vertices of the triangle\n    const v1 = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);\n    const v2 = new THREE.Vector3().fromBufferAttribute(positionAttribute, i + 1);\n    const v3 = new THREE.Vector3().fromBufferAttribute(positionAttribute, i + 2);\n\n    // Calculate volume of the tetrahedron\n    const tetraVolume = v1.dot(v2.cross(v3)) / 6;\n\n    volume += tetraVolume;\n  }\n\n  // Convert to absolute value as the volume can be negative depending on the winding order of triangles\n  volume = Math.abs(volume);\n\n  // Convert volume from cubic millimeters to milliliters (1 mL = 1000 mm^3)\n  const volumeInMilliliters = volume / 1000;\n  this.$emit('volume-calculated', volumeInMilliliters);\n\n  // Return volume in milliliters\n  return volumeInMilliliters;\n},\n\n\n\ncalculateDimensions(geometry) {\n  geometry.computeBoundingBox();\n  const boundingBox = geometry.boundingBox;\n  const width = Math.abs(boundingBox.max.x - boundingBox.min.x);\n  const height = Math.abs(boundingBox.max.y - boundingBox.min.y);\n  const depth = Math.abs(boundingBox.max.z - boundingBox.min.z);\n   // Emit an event with the calculated height\n// Emit an event with the calculated height and original dimensions\nconsole.log(\"Emitting height and original dimensions:\", { height, originalDimensions: { width, height, depth } });\nthis.$emit('height-calculated', { height, originalDimensions: { width, height, depth } });\n\n  return { width, height, depth };\n},\n\n\npositionModelInScene(model) {\n  // Set the position of the model in the scene\n  // Adjust these values based on where you want to place the model\n  model.position.set(0, 0, 0);\n},\n\n\n\n\n\nloadGLTFModel() {\n  const loader = new GLTFLoader();\n\n  loader.load('/assets/resinprinter/scene.gltf', (gltf) => {\n    // Get the bounding box of the loaded GLTF model\n    const box = new THREE.Box3().setFromObject(gltf.scene);\n    const currentDimensions = box.getSize(new THREE.Vector3());\n\n    // Desired dimensions in mm (assuming 1 unit = 1mm)\n    const desiredDimensions = new THREE.Vector3(22.1, 40.3, 22.1);\n\n    // Calculate scaling factors\n    const scaleX = desiredDimensions.x / currentDimensions.x;\n    const scaleY = desiredDimensions.y / currentDimensions.y;\n    const scaleZ = desiredDimensions.z / currentDimensions.z;\n\n    // Apply scaling\n    gltf.scene.scale.set(scaleX, scaleY, scaleZ);\n\n    // Apply shadow and material properties\n    gltf.scene.traverse(node => {\n      if (node.isMesh && node.material) {\n        node.castShadow = true;\n        node.receiveShadow = true;\n        node.material.specular = new THREE.Color(0xaaaaaa);\n        node.material.shininess = 30;\n      }\n    });\n\n    // Add the resin printer to the scene\n    this.$options.scene.add(gltf.scene);\n\n    // Get the center of the scaled model\n    // const center = box.getCenter(new THREE.Vector3());\n     // Get the center of the scaled model\n     const center = new THREE.Box3().setFromObject(gltf.scene).getCenter(new THREE.Vector3());\n\n      // Call setupCameraAndControls with the center\n      this.setupCameraAndControls(center);\n\n\n    // // Add a PointLight at the center of the model\n    const innerLight = new THREE.PointLight(0xffffff, 0.1, 10);\n    innerLight.position.set(center.x, center.y, center.z);\n    this.$options.scene.add(innerLight);\n\n // // Load the environment\n    loader.load('/assets/skyboxes/skyboxanimesky.glb', (gltfSky) => {\n      this.$options.scene.add(gltfSky.scene);\n\n      // Scale the skybox to be larger\n      gltfSky.scene.scale.set(50000, 50000, 5000); // Adjust the scale as needed\n\n\n      gltfSky.scene.traverse(node => {\n        if (node.isMesh) {\n          node.castShadow = true;\n          node.receiveShadow = true;\n        }\n      });\n    });\n\n  });\n},\nloadSTLModel(file) {\n  // Check if the file is of the correct type\n  if (!(file instanceof Blob)) {\n    console.error('Invalid file type:', file);\n    return;\n  }\n\n  // Make sure the fileReader is initialized\n  if (!this.fileReader) {\n    this.fileReader = new FileReader();\n  }\n\n  console.log('Loading STL model:', file.name);\n  const loader = new STLLoader();\n  const self = this;\n\n  // If there is a previously loaded STL model, remove it\n  if (self.loadedSTL) {\n    self.$options.scene.remove(self.loadedSTL);\n  }\n\n  self.fileReader.onload = (e) => {\n    console.log('File read completed, parsing geometry');\n    const geometry = loader.parse(e.target.result);\n\n    if (!geometry) {\n      console.error('Error parsing STL geometry');\n      return;\n    }\n    console.log('Geometry parsed successfully');\n    const material = new THREE.MeshStandardMaterial();\n    const mesh = new THREE.Mesh(geometry, material);\n\n    if (!geometry ?? geometry.type !== 'BufferGeometry') {\n      console.error('Invalid or undefined geometry');\n      return;\n    }\n\n    // Calculate the scaling factor based on the reference cube\n    const scalingFactor = this.calculateScalingFactor(geometry, this.referenceCube);\n    mesh.scale.set(scalingFactor, scalingFactor, scalingFactor); // Apply scaling\n\n    // Calculate and log the dimensions and volume of the STL model\n    const dimensions = this.calculateDimensions(geometry);\n    const printVolume = this.calculateVolume(geometry);\n    console.log(`STL Model Dimensions: ${dimensions.width / 10} x ${dimensions.height / 10} x ${dimensions.depth / 10} cm`);\n    console.log(`STL Model Volume: ${printVolume} mL`);\n    this.$emit('volume-calculated', printVolume);\n\n    // Scale down by a factor of 10\n    mesh.scale.set(0.1, 0.1, 0.1);\n\n    // Rotate the model to be upside down\n    mesh.rotation.z = Math.PI; // Rotate by 180 degrees around the Z-axis\n    mesh.rotation.x = Math.PI / 2; // Rotate by 90 degrees around the X-axis\n\n    // Load the GLTF model to get its center and size\n    const gltfLoader = new GLTFLoader();\n    gltfLoader.load('/assets/resinprinter/scene.gltf', (gltf) => {\n      const gltfBox = new THREE.Box3().setFromObject(gltf.scene);\n      const gltfCenter = gltfBox.getCenter(new THREE.Vector3());\n\n      // Position the STL model in the middle of the GLTF model with its top at the floor\n      mesh.position.set(gltfCenter.x - 1, gltfCenter.y + 18.5, gltfCenter.z + 11);\n\n      // Set the currently loaded STL model\n      self.loadedSTL = mesh;\n\n      console.log('Adding mesh to scene');\n      self.$options.scene.add(mesh);\n    });\n  };\n\n  self.fileReader.onerror = (error) => {\n    console.error('Error reading STL file:', error);\n  };\n\n  console.log('Reading STL file contents');\n  self.fileReader.readAsArrayBuffer(file);\n},\n\n\n\n\n animate() {\n  requestAnimationFrame(this.animate); // This ensures the animate method is called on the next frame\n  this.$options.renderer.render(this.$options.scene, this.$options.camera); // Render the scene with the camera\n}\n    \n    \n  },\n\n\n\n  watch: {\n  floorColor(newColor) {\n    this.updateFloorColor(newColor);\n  },\n\n  enableHDR(newVal) {\n      if (newVal) {\n        this.loadEnvironment(); // Turn on HDR\n      } else {\n        this.$options.scene.environment = null; // Turn off HDR\n      }\n    },\n    showFloor(newVal) {\n      if (this.floorMesh) {\n        this.floorMesh.visible = newVal; // Toggle floor visibility\n      }\n    }\n}\n};\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}