{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  ref: \"rendererContainer\",\n  style: {\n    \"width\": \"100%\",\n    \"height\": \"100%\"\n  }\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, null, 512 /* NEED_PATCH */);\n}","map":{"version":3,"names":["ref","style","_createElementBlock","_hoisted_1"],"sources":["/Users/max/Documents/3DPrintprice-1/src/components/3DViewerComponent.vue"],"sourcesContent":["Look at this code and view the video:\n\n<template>\n  <div ref=\"rendererContainer\" style=\"width: 100%; height: 100%;\"></div>\n</template>\n\n<script>\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { STLLoader } from 'three/examples/jsm/loaders/STLLoader';\n\n\nexport default {\n  name: '3DViewerComponent',\n  props: {\n    updateLights: Function,\n    updateEnvironment: Function,\n    updatenewFloor: Function,\n    enableHDR: Boolean,\n    showFloor: Boolean,\n    floorColor: {\n    type: String,\n    default: '#8c52ff',\n    // Initial properties of the skybox material\n    skyboxProperties: {\n      color: '#333333', // Default color\n      metalness: 0.5,\n      roughness: 0.3,\n      clearcoat: 0.9,\n      clearcoatRoughness: 0.2,\n      reflectivity: 0.5,\n    },\n  }\n    \n  },\n\ndata() {\n    return {\n      currentHDR: '/assets/hdrs/DayInTheClouds4k.hdr',\n      currentFloor: '/assets/floors/pinkfloor2.glb',\n      currentSkybox: '/assets/skyboxes/lightbluesky.glb',\n      currentSkyboxColor: '#FFFFFF', // Default color for skybox\n      isColorSkybox: false, // Flag to determine skybox type\n      scene: null,\n      isReady: false,\n      fileReader: new FileReader(),\n      hdrIntensity: 2, \n      volume: 0, // This will store the volume calculated in the 3D viewer\n\n    };\n  },\n  \n// Add event listeners in the mounted() lifecycle hook\nmounted() {\n  this.$options.scene = new THREE.Scene();\n  this.isReady = true;\n    // Now you can call the passed-in methods like this:\n  this.$options.scene = new THREE.Scene();\n    // Initialize other scene elements\n  this.initializeScene();\n  \n  console.log(\"3DViewerComponent mounted\");\n  this.$emit('viewer-mounted'); // Emit a specific event\n  window.addEventListener('resize', this.handleWindowResize);\n// Add event listeners\n this.$emit('mounted'); \nthis.$emit('update-lights', this.setupLights); \nthis.$emit('update-environment', this.loadEnvironment);\nthis.$emit('update-floor', this.loadFloor);\nthis.$emit('changeSkyboxProperty', this.updateSkyboxMaterial);\n\nthis.animate = this.animate.bind(this); // Bind the method\n  this.animate(); // Start the animation loop\n\n\n\n},\n\n// Remove event listeners in the beforeUnmount() lifecycle hook\nbeforeUnmount() {\n  window.removeEventListener('resize', this.handleWindowResize);\n  this.$emit.$off('update-lights', this.setupLights);\n  this.$emit.$off('update-environment', this.loadEnvironment);\n  this.$emit.$off('update-floor', this.loadFloor); \n},\n\n  methods: {\n    \n    handleWindowResize() {\n      const width = this.$refs.rendererContainer.clientWidth;\n      const height = this.$refs.rendererContainer.clientHeight;\n      this.$options.camera.aspect = width / height;\n      this.$options.camera.updateProjectionMatrix();\n      this.$options.renderer.setSize(width, height);\n    },\n    initializeScene() {\n      \n      this.$options.scene = new THREE.Scene();\n      // Add other scene initializations here\n      console.log(\"Scene initialized\"); \n\n      this.setupRenderer();\n      this.setupCameraAndControls();\n      this.setupLights();\n      this.loadEnvironment();\n      this.loadFloor(); \n      this.animate();\n      this.loadGLTFModel();\n      this.loadReferenceCube('/assets/1cm3cube.stl');\n      this.loadSkybox(this.currentSkybox); // Load the default skybox\n     \n\n      this.$emit('scene-initialized', this.$options.scene); // Emit an event to signal that the scene is initialized\n\n    },\n\n    setupRenderer() {\n      const width = this.$refs.rendererContainer.clientWidth;\n      const height = this.$refs.rendererContainer.clientHeight;\n\n      this.$options.scene = new THREE.Scene();\n      this.$options.scene.background = new THREE.Color(0x111111);\n\n      this.$options.renderer = new THREE.WebGLRenderer({ antialias: true });\n      this.$options.renderer.setSize(width, height);\n      this.$options.renderer.setClearColor(0x111111);\n      this.$options.renderer.shadowMap.enabled = true;\n      this.$options.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.$refs.rendererContainer.appendChild(this.$options.renderer.domElement);\n    },\n\n    setupCameraAndControls(center) {\n      const width = this.$refs.rendererContainer.clientWidth;\n  const height = this.$refs.rendererContainer.clientHeight;\n\n  this.$options.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);\n\n  if (center) {\n    // Set the camera to look at the model\n    this.$options.camera.position.set(center.x, center.y , center.z + 70); // Increase Y and Z for more zoom-out\n    this.$options.camera.lookAt(center);\n  } else {\n    // Default position if center is not provided\n    this.$options.camera.position.set(70, 70, 70);\n  }\n\n  this.$options.controls = new OrbitControls(this.$options.camera, this.$options.renderer.domElement);\n  this.$options.controls.minDistance = 30; // Allow the camera to get closer\n  this.$options.controls.maxDistance = 150; // Allow the camera to move further away\n\n  if (center) {\n    this.$options.controls.target.set(center.x, center.y, center.z);\n  } else {\n    this.$options.controls.target.set(0, 0, 0);\n  }\n\n  this.$options.controls.update();\n},\n\n\n\n\n    setupLights() {\n  // Ambient light to provide overall illumination\n  const ambientLight = new THREE.AmbientLight(0xffffff, 4); // Adjust intensity here\n  this.$options.scene.add(ambientLight);\n\n  // Key light (main light source)\n  const keyLight = new THREE.DirectionalLight(0xffffff, 1.0); // Adjust intensity here\n  keyLight.position.set(-50, 50, 50); // Adjust position\n  this.$options.scene.add(keyLight);\n\n  // Fill light (soft, less intense light to fill in shadows)\n  const fillLight = new THREE.DirectionalLight(0xffffff, 0.5); // Adjust intensity here\n  fillLight.position.set(50, 50, -50); // Adjust position\n  this.$options.scene.add(fillLight);\n\n  // Background light (illuminates the background or backdrop)\n  const backgroundLight = new THREE.DirectionalLight(0xffffff, 5); // Adjust intensity here\n  backgroundLight.position.set(0, 0, -100); // Adjust position\n  this.$options.scene.add(backgroundLight);\n\n  // Rim light (creates a subtle highlight on the subject's edges)\n  const rimLight = new THREE.SpotLight(0xffffff, 1.0, 0, Math.PI / 6, 1); // Adjust intensity here\n  rimLight.position.set(0, 0, 50); // Adjust position\n  this.$options.scene.add(rimLight);\n\n  // Optionally, you can configure shadow maps for specific lights\n  keyLight.castShadow = true;\n  fillLight.castShadow = true;\n  rimLight.castShadow = true;\n\n  // Set up shadow parameters (you may need to adjust these)\n  const shadowMapSize = 1024;\n  keyLight.shadow.mapSize.width = shadowMapSize;\n  keyLight.shadow.mapSize.height = shadowMapSize;\n  fillLight.shadow.mapSize.width = shadowMapSize;\n  fillLight.shadow.mapSize.height = shadowMapSize;\n  rimLight.shadow.mapSize.width = shadowMapSize;\n  rimLight.shadow.mapSize.height = shadowMapSize;\n},\n\n\nupdateSkybox(newSkybox) {\n    console.log('Updating skybox with:', newSkybox);\n\n    // Hide the skybox color sphere if it exists\n    if (this.skyboxColorSphere) {\n        this.skyboxColorSphere.visible = false;\n    }\n\n    if (newSkybox) {\n        // If a new skybox is provided, use it\n        this.currentSkybox = newSkybox;\n        this.isColorSkybox = false; // Reset the color skybox flag\n        this.loadSkybox(); // Load the new skybox into the scene\n    } else {\n        // If no new skybox is provided, use the default\n        this.currentSkybox = this.defaultSkybox;\n        this.loadSkybox(); // Load the default skybox into the scene\n    }\n},\n\n    loadSkybox() {\n      \n  // Remove the previous skybox from the scene if it exists\n  if (this.skyboxMesh) {\n    this.$options.scene.remove(this.skyboxMesh);\n    this.skyboxMesh = null; // Ensure the previous mesh is cleared\n\n    // Remove the background color\n    this.$options.scene.background = null;\n  }\n\n  if (this.isColorSkybox && this.currentSkyboxColor) {\n    // Create a geometry for the skybox. Here, we use a BoxGeometry.\n    const skyboxGeometry = new THREE.BoxGeometry(5000, 5000, 5000);\n\n    // Create a material with the color selected\n    const skyboxMaterial = new THREE.MeshPhysicalMaterial({\n  color: this.currentSkyboxColor, // Base color\n  metalness: 0.5, // 0.0 for non-metallic, 1.0 for fully metallic\n  roughness: 0.3, // 0.0 for smooth, 1.0 for rough\n  clearcoat: 0.9, // Intensity of the clearcoat layer\n  clearcoatRoughness: 0.2, // Roughness of the clearcoat layer\n  reflectivity: 0.5, // Overall reflectivity\n  side: THREE.BackSide, // Important for skybox\n});\n\n    \n    // Create a mesh with the geometry and material\n    this.skyboxMesh = new THREE.Mesh(skyboxGeometry, skyboxMaterial);\n\n    // Add the skybox mesh to the scene\n    this.$options.scene.add(this.skyboxMesh);\n  } else {\n    // Load the default or specified skybox\n    const loader = new GLTFLoader();\n    loader.load(this.currentSkybox, (gltfSkybox) => {\n      this.skyboxMesh = gltfSkybox.scene;\n      this.$options.scene.add(this.skyboxMesh);\n    }, undefined, (error) => {\n      console.error(\"Error loading skybox:\", error);\n    });\n  }\n},\n\n\nupdateSkyboxMaterial(properties) {\n  // Ensure properties are reactive\n  this.$nextTick(() => {\n    console.log(\"Received properties for update:\", properties);\n\n    // Create a default color if none is provided\n    const defaultColor = '#ffffff'; // white color as default\n    const colorValue = properties.color ?? defaultColor;\n\n    // Ensure the color value is a string and starts with '#'\n    const color = new THREE.Color(colorValue.startsWith('#') ? colorValue : `#${colorValue}`);\n    console.log(\"THREE.Color object created:\", color);\n\n    // If the skybox material already exists, update its properties\n    if (this.skyboxMaterial) {\n    \n      this.skyboxMaterial.color.set(color); // Update color\n      this.skyboxMaterial.metalness = properties.metalness ?? this.skyboxMaterial.metalness;\n      this.skyboxMaterial.roughness = properties.roughness ?? this.skyboxMaterial.roughness;\n      this.skyboxMaterial.clearcoat = properties.clearcoat ?? this.skyboxMaterial.clearcoat;\n      this.skyboxMaterial.clearcoatRoughness = properties.clearcoatRoughness ?? this.skyboxMaterial.clearcoatRoughness;\n      this.skyboxMaterial.reflectivity = properties.reflectivity ?? this.skyboxMaterial.reflectivity;\n      this.skyboxMaterial.needsUpdate = true; // Tell Three.js to update the material\n      console.log(\"updated material\");\n    } else {\n      // If the material does not exist, create it with new properties\n      this.skyboxMaterial = new THREE.MeshPhysicalMaterial({\n        color: color,\n        metalness: properties.metalness ?? 0.5,\n        roughness: properties.roughness ?? 0.3,\n        clearcoat: properties.clearcoat ?? 0.9,\n        clearcoatRoughness: properties.clearcoatRoughness ?? 0.2,\n        reflectivity: properties.reflectivity ?? 0.5,\n        side: THREE.BackSide,\n      });\n      console.log(\"updated material1\");\n      // Assuming you have a mesh that uses this material, set it here\n      this.skyboxMaterial.needsUpdate = true; // Tell Three.js to recompile the material's shaders\nthis.skyboxMesh.material = this.skyboxMaterial; // Apply the updated material to the mesh\n    }\n\n    // Update the scene background if a color is provided\n    if (properties.color) {\n      this.$options.scene.background.set(color); // Set the background to the new color\n    }\n\n    // Render the scene again to reflect the changes\n    this.$options.renderer.render(this.$options.scene, this.$options.camera);\n    \n  });\n},\n\n\n\n\n    updateHDR(newHDR) {\n  console.log('Updating HDR with:', newHDR);\n  this.currentHDR = `/assets/hdrs/${newHDR}`;\n  this.loadEnvironment(); // Load the new HDR environment\n},\n\nupdateFloor(newFloor) {\n    console.log('Updating floor with:', newFloor);\n    this.currentFloor = `/assets/floors/${newFloor}`;\n    this.loadFloor(); // Load the new floor into the scene\n  },\n\n\n  updateFloorColor(newColorHex) {\n      if (this.floorMesh) {\n      const newColor = new THREE.Color(newColorHex);\n      this.floorMesh.traverse((node) => {\n        if (node.isMesh && node.material) {\n          node.material.color.copy(newColor);\n      }\n    });\n  }\n},\n\nloadEnvironment() {\n  const pmremGenerator = new THREE.PMREMGenerator(this.$options.renderer);\n  pmremGenerator.compileEquirectangularShader();\n\n  new RGBELoader()\n    .setDataType(THREE.FloatType)\n    .load(this.currentHDR, (texture) => {\n      const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n      \n      // Adjust the intensity here\n      envMap.encoding = THREE.sRGBEncoding; // Ensure correct encoding\n      this.$options.scene.environment = envMap;\n      this.$options.scene.environment.intensity = this.hdrIntensity; // Set intensity\n\n      texture.dispose();\n      pmremGenerator.dispose();\n\n\n      // Check if this.floorMesh is defined before accessing its properties\n      if (this.floorMesh) {\n        // Set the position and scale for the environment\n        this.floorMesh.position.set(0, -8.5, 0); // Horizontal position at y = -0.09\n        this.floorMesh.scale.set(20, 20, 20); // Scale to reach the origin minus 20 units\n      }\n    });\n},\n\nupdateHDRIntensity(newIntensity) {\n  this.hdrIntensity = newIntensity;\n  if (this.$options.scene && this.$options.scene.environment) {\n    this.$options.scene.environment.intensity = newIntensity;\n  }\n},\n\nloadFloor() {\n  const loader = new GLTFLoader();\n\n  // Remove the previous floor if it exists\n  if (this.floorMesh) {\n    this.$options.scene.remove(this.floorMesh);\n  }\n\n  loader.load(this.currentFloor, (gltfFloor) => {\n  if (gltfFloor.scene) {\n    this.floorMesh = gltfFloor.scene;\n\n    // Set the position and scale for the floor\n    this.floorMesh.position.set(0, -8.5, 0); // Horizontal position at y = -0.09\n    this.floorMesh.scale.set(27, 0.01, 27); // Scale to reach the origin minus 20 units\n\n    // Traverse through the nodes and apply the new color to the floor\n    this.floorMesh.traverse((node) => {\n      if (node.isMesh && node.material) {\n        node.material.color.copy(new THREE.Color(this.floorColor));\n      }\n    });\n\n    this.$options.scene.add(this.floorMesh);\n  } else {\n    console.error(\"Failed to load the floor model or scene is undefined.\");\n  }\n}, undefined, (error) => {\n  console.error(\"Error loading floor model:\", error);\n});\n\n},\n\nloadReferenceCube(cubePath) {\n  const loader = new STLLoader();\n  loader.load(cubePath, (geometry) => {\n    const material = new THREE.MeshStandardMaterial({visible: false}); // Invisible as it's just for reference\n    const cubeMesh = new THREE.Mesh(geometry, material);\n    this.$options.scene.add(cubeMesh);\n    this.referenceCube = cubeMesh; // Store for later use\n  });\n},\n\n\ncalculateScalingFactor(mesh) {\n  // Use Squirtle's volume as a reference\n  const squirtleVolume = 203320; // Volume of Squirtle in mm3\n  const modelVolume = this.calculateVolume(mesh.geometry); // Calculate the volume of the STL model\n\n  // Calculate scaling factor based on the volume ratio\n  return Math.cbrt(modelVolume / squirtleVolume);\n},\n\ncalculateVolume(geometry) {\n  // Check if geometry is undefined or not a BufferGeometry\n  if (!geometry ?? !(geometry instanceof THREE.BufferGeometry)) {\n    console.error('Invalid or undefined geometry passed to calculateVolume.');\n    return 0;\n  }\n\n  // Get position attribute\n  const positionAttribute = geometry.getAttribute('position');\n\n  // Check if position attribute exists\n  if (!positionAttribute) {\n    console.error('Geometry does not have position attribute.');\n    return 0;\n  }\n\n  let volume = 0;\n\n  // Iterate over each face (assuming geometry is made of triangles)\n  for (let i = 0; i < positionAttribute.count; i += 3) {\n    // Get vertices of the triangle\n    const v1 = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);\n    const v2 = new THREE.Vector3().fromBufferAttribute(positionAttribute, i + 1);\n    const v3 = new THREE.Vector3().fromBufferAttribute(positionAttribute, i + 2);\n\n    // Calculate volume of the tetrahedron\n    const tetraVolume = v1.dot(v2.cross(v3)) / 6;\n\n    volume += tetraVolume;\n  }\n\n  // Convert to absolute value as the volume can be negative depending on the winding order of triangles\n  volume = Math.abs(volume);\n\n  // Convert volume from cubic millimeters to milliliters (1 mL = 1000 mm^3)\n  const volumeInMilliliters = volume / 1000;\n  this.$emit('volume-calculated', volumeInMilliliters);\n\n  // Return volume in milliliters\n  return volumeInMilliliters;\n},\n\n\n\ncalculateDimensions(geometry) {\n  geometry.computeBoundingBox();\n  const boundingBox = geometry.boundingBox;\n  const width = Math.abs(boundingBox.max.x - boundingBox.min.x);\n  const height = Math.abs(boundingBox.max.y - boundingBox.min.y);\n  const depth = Math.abs(boundingBox.max.z - boundingBox.min.z);\n   // Emit an event with the calculated height\n// Emit an event with the calculated height and original dimensions\nconsole.log(\"Emitting height and original dimensions:\", { height, originalDimensions: { width, height, depth } });\nthis.$emit('height-calculated', { height, originalDimensions: { width, height, depth } });\n\n  return { width, height, depth };\n},\n\n\npositionModelInScene(model) {\n  // Set the position of the model in the scene\n  // Adjust these values based on where you want to place the model\n  model.position.set(0, 0, 0);\n},\n\n\n\n\n\nloadGLTFModel() {\n  const loader = new GLTFLoader();\n\n  loader.load('/assets/resinprinter/scene.gltf', (gltf) => {\n    // Get the bounding box of the loaded GLTF model\n    const box = new THREE.Box3().setFromObject(gltf.scene);\n    const currentDimensions = box.getSize(new THREE.Vector3());\n\n    // Desired dimensions in mm (assuming 1 unit = 1mm)\n    const desiredDimensions = new THREE.Vector3(22.1, 40.3, 22.1);\n\n    // Calculate scaling factors\n    const scaleX = desiredDimensions.x / currentDimensions.x;\n    const scaleY = desiredDimensions.y / currentDimensions.y;\n    const scaleZ = desiredDimensions.z / currentDimensions.z;\n\n    // Apply scaling\n    gltf.scene.scale.set(scaleX, scaleY, scaleZ);\n\n    // Apply shadow and material properties\n    gltf.scene.traverse(node => {\n      if (node.isMesh && node.material) {\n        node.castShadow = true;\n        node.receiveShadow = true;\n        node.material.specular = new THREE.Color(0xaaaaaa);\n        node.material.shininess = 30;\n      }\n    });\n\n    // Add the resin printer to the scene\n    this.$options.scene.add(gltf.scene);\n\n    // Get the center of the scaled model\n    // const center = box.getCenter(new THREE.Vector3());\n     // Get the center of the scaled model\n     const center = new THREE.Box3().setFromObject(gltf.scene).getCenter(new THREE.Vector3());\n\n      // Call setupCameraAndControls with the center\n      this.setupCameraAndControls(center);\n\n\n    // // Add a PointLight at the center of the model\n    const innerLight = new THREE.PointLight(0xffffff, 0.1, 10);\n    innerLight.position.set(center.x, center.y, center.z);\n    this.$options.scene.add(innerLight);\n\n // // Load the environment\n    loader.load('/assets/skyboxes/skyboxanimesky.glb', (gltfSky) => {\n      this.$options.scene.add(gltfSky.scene);\n\n      // Scale the skybox to be larger\n      gltfSky.scene.scale.set(50000, 50000, 5000); // Adjust the scale as needed\n\n\n      gltfSky.scene.traverse(node => {\n        if (node.isMesh) {\n          node.castShadow = true;\n          node.receiveShadow = true;\n        }\n      });\n    });\n\n  });\n},\nloadSTLModel(file) {\n  // Check if the file is of the correct type\n  if (!(file instanceof Blob)) {\n    console.error('Invalid file type:', file);\n    return;\n  }\n\n  // Make sure the fileReader is initialized\n  if (!this.fileReader) {\n    this.fileReader = new FileReader();\n  }\n\n  console.log('Loading STL model:', file.name);\n  const loader = new STLLoader();\n  const self = this;\n\n  // If there is a previously loaded STL model, remove it\n  if (self.loadedSTL) {\n    self.$options.scene.remove(self.loadedSTL);\n  }\n\n  self.fileReader.onload = (e) => {\n    console.log('File read completed, parsing geometry');\n    const geometry = loader.parse(e.target.result);\n\n    if (!geometry) {\n      console.error('Error parsing STL geometry');\n      return;\n    }\n    console.log('Geometry parsed successfully');\n    const material = new THREE.MeshStandardMaterial();\n    const mesh = new THREE.Mesh(geometry, material);\n\n    if (!geometry ?? geometry.type !== 'BufferGeometry') {\n      console.error('Invalid or undefined geometry');\n      return;\n    }\n\n    // Calculate the scaling factor based on the reference cube\n    const scalingFactor = this.calculateScalingFactor(geometry, this.referenceCube);\n    mesh.scale.set(scalingFactor, scalingFactor, scalingFactor); // Apply scaling\n\n    // Calculate and log the dimensions and volume of the STL model\n    const dimensions = this.calculateDimensions(geometry);\n    const printVolume = this.calculateVolume(geometry);\n    console.log(`STL Model Dimensions: ${dimensions.width / 10} x ${dimensions.height / 10} x ${dimensions.depth / 10} cm`);\n    console.log(`STL Model Volume: ${printVolume} mL`);\n    this.$emit('volume-calculated', printVolume);\n\n    // Scale down by a factor of 10\n    mesh.scale.set(0.1, 0.1, 0.1);\n\n    // Rotate the model to be upside down\n    mesh.rotation.z = Math.PI; // Rotate by 180 degrees around the Z-axis\n    mesh.rotation.x = Math.PI / 2; // Rotate by 90 degrees around the X-axis\n\n    // Load the GLTF model to get its center and size\n    const gltfLoader = new GLTFLoader();\n    gltfLoader.load('/assets/resinprinter/scene.gltf', (gltf) => {\n      const gltfBox = new THREE.Box3().setFromObject(gltf.scene);\n      const gltfCenter = gltfBox.getCenter(new THREE.Vector3());\n\n      // Position the STL model in the middle of the GLTF model with its top at the floor\n      mesh.position.set(gltfCenter.x - 1, gltfCenter.y + 18.5, gltfCenter.z + 11);\n\n      // Set the currently loaded STL model\n      self.loadedSTL = mesh;\n\n      console.log('Adding mesh to scene');\n      self.$options.scene.add(mesh);\n    });\n  };\n\n  self.fileReader.onerror = (error) => {\n    console.error('Error reading STL file:', error);\n  };\n\n  console.log('Reading STL file contents');\n  self.fileReader.readAsArrayBuffer(file);\n},\n\n\n\n\n animate() {\n  requestAnimationFrame(this.animate); // This ensures the animate method is called on the next frame\n  this.$options.renderer.render(this.$options.scene, this.$options.camera); // Render the scene with the camera\n}\n    \n    \n  },\n\n\n\n  watch: {\n  floorColor(newColor) {\n    this.updateFloorColor(newColor);\n  },\n\n  enableHDR(newVal) {\n      if (newVal) {\n        this.loadEnvironment(); // Turn on HDR\n      } else {\n        this.$options.scene.environment = null; // Turn off HDR\n      }\n    },\n    showFloor(newVal) {\n      if (this.floorMesh) {\n        this.floorMesh.visible = newVal; // Toggle floor visibility\n      }\n    }\n}\n};\n</script>\n"],"mappings":";;EAGOA,GAAG,EAAC,mBAAmB;EAACC,KAAkC,EAAlC;IAAA;IAAA;EAAA;;;uBAA7BC,mBAAA,CAAsE,OAAtEC,UAAsE"},"metadata":{},"sourceType":"module","externalDependencies":[]}